% 计原 - 大实验成果交流
% 涂珂 2011011273\
傅左右 2011011264\
计14 - 402组
% \today


# 实验成果一览

## 实验成果参数

- CPU主频为6.25MHz（12.5MHz有时会出一些问题，所以只能二分之，6.25MHz是稳定频率）

- RAM频率为25MHz

- 正常运行kernel内核程序，正常运行所有project1程序。

- VGA分辨率为640*480，VGA（显存）运行频率25MHz


## 实验成果简列

- 清晰的模块分工

- 指令集改进，指令集汇编工具

- 数据旁路元件

- 冒险检测单元

- 完整的VGA、LED、可调时钟调试工具链

- FLASH自启动

- 使用地址映射，统一管理外围I/O设备

- 串口通信

- VGA、键盘交互
	- VGA等宽ASCII字符集显示
	- VGA双端FIFO显存
	- 键盘输入、支持换行、发送串口与VGA的记事本程序

# 设计方案

------------------

![数据通路图 datapath.png](datapath.png)

------------------

![RTL综合图 cpu-schematic.pdf](cpu-schematic.png)


# 重新设计、并且成功实现指令集任务

## 指令集(402)

1. THCO MIPS 基本指令集

2. 扩展指令集
	- JRRA
	- SLTI
	- ADDSP3
	- NOT
	- SLT

## 重新设计指令

 - 用前5位表示op。共30条。
 - 加*为扩展指令。
 - XXX，YYY，ZZZ为寄存器标号。
 - III为立即数。
 - 把类型相近的op连续起来，这样写代码就可以用大于小于判断了。

## R型指令

\begingroup
\ttfamily

R		指令结构
----	----------------
MFIH	00001XXX00000000
MFPC	00010XXX00000000
MTIH	00011XXX00000000
MTSP	00100XXX00000000
AND		00101XXXYYY00000
OR		00110XXXYYY00000
*NOT	00111XXXYYY00000
*SLT	01000XXXYYY00000
CMP		01001XXXYYY00000
SLL		01010XXXYYYIII00
SRA		01011XXXYYYIII00
ADDU	01100XXXYYYZZZ00
SUBU	01101XXXYYYZZZ00

\endgroup

## I型指令

\begingroup
\ttfamily

I		指令结构
-----	----------------
ADDSP	01110IIIIIIII000
LW_SP	01111XXX00000000
ADDIU	10000XXXIIIIIIII
*SLTI	10001XXXIIIIIIII
*ADDSP3	10010XXXIIIIIIII
LI		10011XXXIIIIIIII
ADDIU3	10100XXXYYY0IIII
LW		10101XXXYYYIIIII
SW		10110XXXYYYIIIII
SW_SP	10111XXXYYYIIIII

\endgroup

## B型指令

\begingroup
\ttfamily

B		指令结构
-----	----------------
B		11000IIIIIIIIIII
BTEQZ	11001IIIIIIII000
BEQZ	11010XXXIIIIIIII
BNEZ	11011XXXIIIIIIII

\endgroup

## J型、NOP指令

\begingroup
\ttfamily

J		指令结构
-----	----------------
*JRRA	1110000000000000
JR		11101XXX00000000


-----	----------------
NOP		0000000000000000
-----	----------------

\endgroup


## 借助汇编器thcoas.py (by taccoraw)

我们在武祥晋同学(2011011278)的基于python实现的汇编翻译器的基础上进行了改进，实现了对我们自己定义的指令集的编译工作。

改进后的汇编器可以将MIPS汇编代码编译输出二进制文件，并在命令行上输出丰富的调试信息（二进制、十六进制代码、代码原文行号、翻译后的代码地址号、相应指令），从而极大的方便了后续的调试。（尤其是需要蛋疼的单步跟踪的时候= =）

![汇编器截图 （代码原文行号、二进制、十六进制代码、翻译后的代码地址号、相应指令）](assembler.jpg)


# 扩展成果分享

## 1. 数据旁路, 冒险检测

- 数据冲突检测单元，看寄存器堆取出的值是否是EXE 或MEM 阶段未写回的值，若是，则通过旁路引回。共引入了4 条旁路。

- 控制冲突检查单元，主要是检测跳转指令所导致的寄存器未写回的冲突，并产生信号通过辅助的旁路元件处理解决相应的冲突。主要是提前判断跳转指令而寄存器未写回的冲突.引入了2条旁路.

------------------

![旁路与冒险检测 数据通路示意](datapath-2.png)


## 2. 外围设备综合管理

我们在总线上设计了一个负责与所有外围设备的通信的模块MemoryTop，向CPU封装所有的外围设备的逻辑，由此分担工作、并简化CPU内部设计。

其原理可描述为：CPU从MemoryTop获取指令和数据，写入数据也需要通过MemoryTop。我们的MemoryTop负责管理RAM、FLASH、串口、PS2、VGA，以及相应的地址映射。通过“SW”、“LW”指令，并配合相应的地址，就能完成读写外围设备的功能。

MemoryTop以管理的设备分为下列几个子模块：

 - Flash管理（实现Flash自启动）
 
 - RAM读写（负责取指、写存的关键部位）
 
 - 键盘信息转发
 
 - 串口管理
 
 - 显存管理（VGA）

## 2.1 论如何科学的使用VGA（其实很弱的- -）

可接受一个11位地址、8位数据、1位写使能的输入。用来写FIFO显存。显存和字模骨架是通过Xilinx的IP Core实例化得到。

**字模(char\_mem)**：通过编写的辅助程序，从等宽字库中抽取ASCII可打印字符的字模。进行地址映射和补0。最后生成一个10 * 15点阵。零扩充之后得到一个整的16 * 16 * 95内存空间。

**显存(fifo\_mem)**：整个VGA被设计为以一个字符显示（16 * 16）为单位，故相当于横向能放40个字符，竖向能放30个字符。也就是说显存只需要保存40 * 30个字符（7位）即可，将其零扩充得到64 * 32 * 8位深度的显存。

**零扩充**：零扩充虽然浪费了一定的门空间，但是带来的好处是显然的，即 _不需要乘法运算，只需要进行vector的连接运算就能计算显存与字模地址_ 。

## 2.1 论如何科学的使用VGA - 2

`vector_x`是0-639的横坐标，`vector_y`是0-479的纵坐标。VGA是水平逐行扫描的。于是只需取`vector_x`前6位和`vector_y`的前5位进行显存寻址（获得7位表示字符编码的vector），就能表示某一个点正落在哪个字符的区域内。

于是接下来取他们的后4位，再连接上7位表示字符的vector，进行字模寻址（获得1位当前点是否为亮点的boolean），就能表示当前字符下，该点的显示内容。我们没有考虑颜色，1表示当前点显示，即为红色。

按照如上的原理就能完成整个屏幕的显示。只需要简单的连接指令，不需要额外的乘法除法运算。减少计算延迟和减轻硬件负担。


## 3. FLASH自启动

由于是MemoryTop管理时钟。MemoryTop一开始（或者rst）会进入一个从FLASH拷贝代码到RAM2上的自动机状态。拷贝代码的长度是一定的（0x0FFF）。然后MemoryTop再在其四个状态机中循环的时候向CPU输出时钟。于是CPU就从内核代码开始执行，于是启动过程顺利完成。

## 4. 地址映射

主要存储：

- 系统程序区：0x0000-0x3FFF,16K
- 用户程序区：0x4000-0x7FFF,16K
- 系统数据区：0x8000-0xBEFF,16K
- 用户数据区：0xC000-0xF000,16K

外围设备：

- 串口
	- 串口1数据寄存器：0xBF00
	- 串口1状态寄存器：0xBF01
- 键盘
	- 串口2数据寄存器：0xBF02
	- 串口2状态寄存器：0xBF03
- VGA
	- FIFO显存：0xF000-0xFFFF,3K

# 成果展示

------------------

![正确无误的运行斐波那契数列](fib.jpg)

------------------

![与计算机串口通信，写串口“23\\r\\n”](serial.jpg)

------------------

![通过PS2键盘输入，然后将输入译码为ASCII码，将结果发送至串口，同时显示在VGA上。在VGA上的显示支持换行。读取键盘输入和VGA显示、串口发送，这些都是通过编写程序读取设备的映射地址获取设备数据而做到的。](notepad2.jpg)

------------------

![整体测试图](totaltest.jpg)

# 分享一点点调试的经验

## 代码调试 - VGA

硬件的debug真是一件困难的事，它不能像软件一样输出一堆调试信息。我们只能利用有限的LED灯来debug，于是我们在RegFile中实现了一个debug模块，他能实时的通过改变开关的输入来改变显示的寄存器。后来我们写好了vga，就能输出信息在vga上来调试了，效率更高。

## 代码调试 - 传说中的单步跟踪
 
整个实现过程中遇到的最大的bug就是在我们刚开始运行kernel代码的时候，我们通过Term+串口+R命令试图读寄存器的值，总是在一个寄存器里出现了随机的结果，但是我们用led看到寄存器里的值的确是正确的。一开始我们以为是我们串口写得不对，后来用串口精灵仔细检查了一下，发现我们串口应该没有错，而只是多输出了一个值，我们认为那应该是执行kernel代码时的出现的错误，于是我们把kernel中每一个功能部分（于是第一次作业阅读kernel源代码就用上了）单独取出来一个阶段一个阶段的进行调试。最后我们把读寄存器的部分单独拿出来，然后通过手按clk单步执行代码来debug。这里涉及到手按与自动时钟的切换，我们写了一个模块来通过开关来快速切换两种时钟。最后单步执行观察寄存器的值发现时BTEQZ的一个冲突没解决好，导致多循环了一次。于是我们就恍然大悟原来是多循环了一次所以向串口多输出了一个无效值。于是我们马上在riskchecker中多加入一条旁路检查，然后程序顺利正常运行。

------------------

![做的过程实在是太苦逼了！但是做出来又是非常快乐的=w=](hardwork2.jpg)

------------------

The End. Thank you All :P!

